---
layout: presentation
title: Object Orientation
permalink: /object-orientation/
---

class: center, middle

# Object-Oriented Programming
> Object-oriented programming is an exceptionally bad idea which could only have originated in California.
> 
> â€“[Edsger Dijkstra](http://harmful.cat-v.org/software/OO_programming/)

---

# Agenda

1. [Overview](#concept)
1. [Black Box](#black-box)
1. [Files](#example-1)
1. [Dogs](#example-2)
1. [Creating Difference](#difference)
1. [Conclusions](#conclusions)

---

name: overview

# Overview

---

template: overview
name: overview-1

## Concept
Object-Oriented Programming (OOP) is the standard programming paradigm of today.  Nearly all major contemporary programming languages offer the ability to program with objects.

--

- code is written to represent virtual *things*.

--

- each thing has certain **properties** (i.e. variables) that belong to it.

--

- each thing has certain **actions** (i.e. methods) that it can perform.

---

template: overview
name: overview-2

## Concept (continued)
With object-oriented programming, a developer writes a *description* of things of a certain type.

--

- This acts as a fixed plan or *concept* for things of this type - a **class**.

--

- Things are then created that *embody* the abstract concept - **objects**.

---

template: overview
name: concept-digression

## Digression
In the 5th century, B.C., the astonishingly brilliant philsopher, Plato, described what we now call the [Theory of Forms](https://philosophynow.org/issues/90/Plato_A_Theory_of_Forms).

--

- In this theory, **forms** are the non-physical essences of all things, of which **objects** in the physical world are merely imitations or stand-ins.

--

- Things, transient as they are, are not as **real** or true as the eternal concepts or blueprints from whence they come.

--

- So, for example, any given **tree** is not as real as the concept of Tree.

--

- But we cannot **encounter** forms directly, only through the objects that embody them.

--

- It took us only 2.5 thousand years to get that into code form.

---

template: overview
name: overview-2

## Understand this: it's imperative!
Object-oriented programming is a variety of **imperative programming**.

--

- The goal of imperative programming is to design code such that one is able to instruct a particular thing to perform a particular action, have it complete that action, and not worry about the implementation details of how that goal was achieved.

--

- The internals of *how* the thing gets the job done are uninteresting and should be **hidden** from a user of the thing.

---

name: black-box

# Black Box Metaphor

---

template: black-box
name: black-box-1

## Smoke and mirrors
Imperative-style programming attempts to put to practice the [black box metaphor](https://en.wikipedia.org/wiki/Black_box) of engineering, where, provided particular inputs, a machine produces a predictable output and the user of it doesn't have to know the implementation details.

![Black box metapahor](../images/oop-black-box-metaphor.png)

---

template: black-box
name: black-box-2

## Digression
The black box approach transcends any one discipline.  For example, it was popular in the [Behaviorist school of psychology](https://en.wikipedia.org/wiki/Behaviorism), which held that human psychology could be defined by the empirically observed responses to given stimuli, regardless of the internal psychological thought patterns internal to the person.

--

- It modeled humans as input-output machines.... black boxes where it was not necessary to understand the psychology of the person.

--

- A pioneer of this movement was [B.F. Skinner](https://en.wikipedia.org/wiki/B._F._Skinner), who purportedly raised his own children in literal black boxes!

---

template: black-box
name: black-box-2c

## Digression (continued)
![Skinner box](../images/oop-skinner-box.jpg)

---

name: example-1

# Example 1 - Files

---

template: example-1
name: example-1a

## Concept
Imagine you wanted to write code that represented **files** on a computer's hard drive.

---

template: example-1
name: example-1b

## Properties
Every file on the hard drive might have some properties, e.g.
- the data stored within the file
- metadata: filename, size, date modified, etc.

--

These properties represent the *internal state* of any given file.

--

- Their values describe the state of the file at a given moment in time.

---

template: example-1
name: example-1c

## Actions...
If we say a file is in control of its own destiny (a big if), we could say a file has a few actions it could take, e.g.:
- update the data it holds
- change its filename
- save itself to a particular location on the hard drive

---

template: example-1
name: example-1d

## ... and their consequences
These actions represent a *public interface* through which other code can interact with any given file and instruct it what actions to take.

--

```java
// telling the thing what to do...
myFile.setFilename("foobar.txt");
myFile.storeData(someData);
```

--

Calling these methods automatically updates the internal state of the *thing*.

--

```java
// ...causes an internal update of its state - i.e. the values of the properties
filename = "foobar.txt";
data = someData;
```

---

template: example-1
name: example-1d

## UML class diagram
There is a standardized way of representing such *things*, called the Unified Modeling Language (UML).  Here is an example of a UML '**class**' diagram:

![UML file example](../images/oop-uml-file-example.png)

---

template: example-1
name: example-1e

## Class definition
This diagram can be translated into code as such:

```java
public class File {
    // properties
    private byte[] data;
    private String filename;
    private int size;
    private int modifiedDate;

    // actions
    public byte[] getData() { ... };
    public void setData(byte[] data) { ... };
    public String getFilename() { ... };
    public void setFilename(String filename) { ... };
    public void saveTo(String filePath) { ... };
}
```

---

template: example-1
name: example-1f

## Intention
A **class** definition is a template from which as many **objects** can be made as we like.

--

- Each specific File object has its own copy of the properties and methods defined in the File class.

--

- Each specific File object can have its own specific set of values for the properties defined in the class.

--

- Each specific File object will respond to calls to it using any of the methods defined in the class.

--

- The internal state of each object is hidden by making the properties private.  Code written inside other class definitions cannot see them.

---

name: example-2

# Example 2 - Dogs

---

template: example-2
name: example-2a

## Concept
Imagine a **dog**.

---

template: example-2
name: example-2b

## Properties
Every dog might have some properties, e.g.
- name
- age
- breed
- weight

--

Different dogs will probably have different values for each of these properties.

--

- The value of each dog's properties at any given moment in time repesents that dog's **internal state**.

---

template: example-2
name: example-2c

## Actions...
If we say a dog is in control of its own destiny (a big if), we could say a dog has a few actions it could take, e.g.:

--

- bark

--

- fetch

--

- sleep

---

template: example-2
name: example-2d

## ... and their complications
Two dogs with different property values might implement these same actions slightly differently.

--

- For example, a small lap dog might have a rapid fire tinny yapping sort of bark, while a large shepherd might occasionally produce a mellow deep woof sound.

--

- A young dog might generally successfully fetch an object, while an elderly dog, or one with a physical handicap, might generally fail at this.

--

- A breed known for its abilities as a guard dog might bark more often and more fiercely than others.

---

template: example-2
name: example-2g

## UML class diagram
A UML class diagram for this dog thing:

![UML dog example](../images/oop-uml-dog-example.png)

---

template: example-2
name: example-2h

## Class definition
This diagram can be translated into code as such:

```java
public class Dog {
    // properties
    private String name;
    private int age;
    private String breed;
    private int weight;

    // actions
    public void bark() { ... };
    public void fetch() { ... };
    public void sleep() { ... };
}
```

---

template: example-2
name: example-2i

## Intention
This Dog **class** definition is a template from which as many Dog **objects** can be made as we like.

---

template: example-2i
name: example-2j

- Each specific Dog object has its own specific values for each of the properties the class defines.

---

template: example-2j
name: example-2k

- Each specific Dog object will respond to calls to any of the methods that the File class defines.

---

template: example-2k
name: example-2l

- The actions produced by these method calls may differ slightly, depending upon the internal state of each Dog object

---

name: difference

# Difference

---

template: difference
name: difference-1

## Constructing different objects from the same class
Our intention in creating a class is to be able to instantiate multiple distinct objects from that class template.


---

template: difference-1
name: difference-2

- We typically want these objects to have some differences from one-another.

---

template: difference
name: difference-2

## No difference
The following code, *placed in the code of some other class definition*, would instantiate two Dog objects from our Dog class.

```java
Dog dog1 = new Dog();
Dog dog2 = new Dog();
```

---

template: difference-2
name: difference-2a

These are different *things* in memory.  [See for yourself.](https://repl.it/repls/QuizzicalBubblyChapter)
```java
(dog1 == dog2) // false... they are different references
```

--

But they do not have any difference in terms of their *internal states*.

--

- `String name` -> `null` by default
- `int age` -> `0` by default
- `String breed` -> `null` by default
- `int weight` -> `0` by default

---

template: difference
name: difference-3

## Difference!

If the internal properties of each Dog object were **public** or **protected** (which they are not), it might be possible to  give each object distinct values:

--

```java
Dog dog1 = new Dog();
// the following won't work, since the Dog's properties are all private
dog1.name = "Fido";
dog1.breed = "Bugle";
dog1.age = 10;

Dog dog2 = new Dog();
// the following won't work, since the Dog's properties are all private
dog2.name = "Tobik";
dog2.breed = "German Shepherd";
dog2.age = 3;
```

--

But this requires us to make visible the internal properties of the object, which goes against the black box metaphor and imperative-style programming.

---

template: difference
name: difference-3

## Difference! (continued)
If we were able to set each Dog's name, breed, and age to different internal states, while retaining hidden internal properties for each object, then we would achieve our goal.

--

We would like to be able to do something like this:
```java
Dog dog1 = new Dog("Fido", "Bugle", 10);
Dog dog2 = new Dog("Tobik", "German Shepherd", 3);
```

--

At the moment, our class definition provides no mechanism for setting a given object's internal properties.

---

template: difference
name: difference-4

## Constructors
In order to be able to set each object's properties discretely, we need to modify the Dog class to have a special **constructor** function.

--

```java
public class Dog {

    // a constructor function!
    public Dog(String name, String breed, int age) {
        // set this object's internal properties
        this.name = name;
        this.breed = breed;
        this.age = age;
    }

    // properties
    private String name;
    private int age;
    private String breed;
    // and so on...
//...
```

---

template: difference
name: difference-5

## Instantiating objects
With constructor functions, we can instantiate as many objects as we like with whatever property values we want them to have.

--

```java
Dog dog1 = new Dog("Fido", "Bugle", 10);
Dog dog2 = new Dog("Tobik", "German Shepherd", 3);
```

[Try it](https://repl.it/repls/AcidicOrangeredProcess)

---

template: difference
name: difference-6

## Instantiating objects (continued)

We could make 101 Dalmatians with random names and ages, if we wanted...
```java
// let's make a random mix of names and ages objects
String[] names = "Patch,Lucky,Cadpig,Roly Poly,Penny,Freckles,Pepper".split(",");
int[] ages = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 };

Dog[] dogs = new Dog[101]; // will hold 101 Dalmatians

for (int i=0; i<dogs.length; i++) {
    // assign each dog random property values from these arrays
    String randomName = names[ (int) (Math.random() * names.length) ];
    int randomAge = ages[ (int) (Math.random() * ages.length) ];

    dogs[i] = new Dog( randomName, "Dalmatian", randomAge ); // instantiate a Dog object

    dogs[i].bark(); // make each dog bark

}
```

[Try it!](https://repl.it/repls/ExtraneousAdolescentConnection)

---

template: difference
name: difference-7

## Changing internal state
Constructors allow us to set up an object's internal state at the moment of its creation.  But what if we wanted to update those values at some later date?

--

- For example, what if one of the 101 Dalmatians has a [happy] birthday and is now a year older... can we not update the age property?

--

- In other words, we would like to be able to do something like this:

```java
// instantiate an object with an initial internal statee
Dog dog1 = new Dog("Fido", "Bugle", 10);

// do some very important significant stuff...

// update the object's internal state at some later point
dog1.age = dog1.age + 1; // happy birthday!

```

--

By now, you know that this is not possible.  The internal properties are **private** and cannot be accessed from 'user' code in a different class.

---

template: difference
name: difference-8

## Setters
To change an object's internal state, we need a '**setter**' function to allow us to set the value of an existing object.

--

```java
public class Dog {
    // ...etc etc

    // a setter function
    public void setAge(int age) {
        // first validate the value, and then use it if good
        if (age > 0 && this.age < 15) this.age = age;
    }

    // ...and so on and so forth
// ...
```

--

- Note that the setter method performs **validation** - it only allows good values to be placed into the property - this is typical of setters.

--

- Note also that the method is *public*, so it can be called from code outside the `Dog` class.

---

template: difference
name: difference-9

## Setters (continued)
With setters, it is possible to set the values of properties on existing objects.

--

Assuming we have created a Dog object...
```java
Dog dog1 = new Dog("Roly Poly", "Dalmatian", 10); // instantiate a dog
```

--

...we can now update its age using the setter
```java
dog1.setAge(11);
```

---

template: difference
name: difference-9

## Accessing internal state
What if you wanted to know a particular Dog's age... how could you find that out programmatically?

--

- For example, instead of hard-coding `11` in the statement `dog1.setAge(11);`, could we have programmatically determined `dog1`'s current age and simply added one to that?

--

- We certainly cannot do the following, since the age property is *private* and cannot be read from code outside the `Dog` class: 

```java
dog1.setAge ( dog1.age + 1 )
```

---

template: difference
name: difference-10

## Getters
Of course, we can allow access to an object's internal state.  But we need to create '**getter**' functions to do so.

--

```java
public class Dog {
    // ...etc etc

    // a getter function
    public int getAge() {
        // simply return the value of the age property
        return this.age;
    }

    // ...and so on and so forth
// ...
```

--

- Note that this function simply returns the value of a private property of the object.  It may seem a bit redundant, but this is typical of getters.

--

- Note also that the method is *public*, so it can be called from code outside the `Dog` class.

---

template: difference
name: difference-11

## Getters (continued)

With a getter function, we can read the current value of a property of an object...

--

```java
System.out.println ( dog1.getAge() ); // will output dog1's age
```

--

... and use that information to help us understand that object's internal state
```java
dog1.setAge( dog1.getAge() + 1 );
```

--

Knowledge of an object's internal state can help us make decisions
```java
if ( dog1.getBreed().equals("Dalmation") && dog1.getName().equals("Pepper") ) {
    // use your imagination
}
```

---

name: conclusions

# Conclusions

--

You now have a basic understanding of object-oriented programming.  Well done.

--

- Thank you.  Bye.


