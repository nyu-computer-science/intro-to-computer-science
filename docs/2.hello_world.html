---
layout: presentation
title: Course overview
permalink: /starter-kit/
---

class: center, middle

# Starter kit
Welcome

---

# Agenda

1. Assumptions
2. Navigating with *NIX
3. Starter code
4. Better starter code
5. Conclusions

---

class: center, middle

# Assumptions

---

# Assumptions
## Ability to run *NIX commands
In order to run Unix or Linux commands, you will need a terminal emulator:
- OS X users already have the Terminal app we will use for this purpose.
- Windows users must have [Git for Windows](https://gitforwindows.org/) installed.

---

# Assumptions
## Ability to execute Java programs
You will need to have the [Java Development Kit](https://www.oracle.com/technetwork/java/javase/downloads/) installed.

If you have any terminal emulators open (such as Terminal or Git Bash), close them and reopen them.

---

# Assumptions
## Understanding of plain text
Plain text is a term frequently used to mean one data on a computer that is represented as codes in the ASCII encoding system or the Unicode encoding system, a successor to ASCII.

These coding systems map specific numeric codes to every text character.  For example, the letter `a` is 97, `b` is 98, and so on and so forth.  

When you as a human see plain text on your screen or type text characters on your keyboard, chances are the computer behind the scenes will store that text's numeric codes (in binary) according to one of these two encoding systems.  

A plain text file is a file that has nothing but numeric codes that map out to characters in one of these systems.  Unicode is today's standard and includes all the Anglocentric characters ASCII did, plus characters of all other languages.

---

# Assumptions
## Ability to edit text
Computer programming code is plain text.  In order to edit code, you will need a decent plain text editor program.
- Install [Sublime Text](https://www.sublimetext.com/), a free good quality plain text editor.
- Sublime Text is freeware, but periodically will ask for donations. You are not required to donate.

### Warnings
- Never use TextEdit on OS X to edit code.
- Never use Notepad on Windows to edit code.
- Do not use Microsoft Word or Google Docs to edit code
- Beware of emacs, lest you find yourself forever dreaming of keyboard shortcuts.

---

# Assumptions
## Ability to edit text
Emacs is a plain text editor that can be run from the command line.

If you want to have the most fun with the *NIX command line, use Emacs instead of Sublime Text.

Emacs functionality depends upon a lot of keyboard shortcut combinations.  The following will get you started:
- `Ctrl-x Ctrl-s` to save a file
- `Ctrl-x Ctrl-c` to quit emacs

Learn more shortcuts with an [emacs cheat sheet](https://duckduckgo.com/?q=emacs+cheat+sheet&t=brave&ia=cheatsheet&iax=1).

---

class: center, middle

# Navigating with *NIX

---

# Navigating with *NIX
## Overview
Unix commands are necessary in order to be able to navigate directories/folders in a UNIX-like system.
- all Unix commands are run in the command-line interface, such as that offered by Terminal on OS X or Git Bash on Windows.

Review [basic Unix commands](https://knowledge.kitchen/Basic_UNIX/Linux_file_management).

---

# Navigating with *NIX
## Where am I?
At any point in time, you are actively within one specific directory, known as the current working directory.  To determine which directory that is at any point, run the `pwd` command:

```console
foo@bar$ pwd
/Users/foo
```

It's fine to read about this, but you'll learn better if you try it out yourself.

Read more about the [current working directory](https://knowledge.kitchen/Basic_computer_concepts#The_working_directory).

---

# Navigating with *NIX
## How do I go up one level
To navigate up one level in the directory structure of your hard drive, use the `..` shortcut no matter where you currently are.

```console
foo@bar$ pwd
/Users/foo
foo@bar$ cd ..
foo@bar$ pwd
/Users
foo@bar$ cd ..
foo@bar$ pwd
/
```

We have now navigated to the root directory, represented by the symbol `/`.


---

# Navigating with *NIX
## How do I get to the top?
To navigate to the top-most directory of your hard drive, known as the "root directory", use the `cd` command with the `/` symbol indicating root directory as the desired destination.

```console
foo@bar$ cd /
foo@bar$ pwd
/
```

The current working directory is now the root directory.

---

# Navigating with *NIX
## How do I see what directories and files are within the current working directory?
Use the `ls` command to show non-hidden files and directories that are within the current working directory.

```console
foo@bar$ ls
dir1    dir4    file2
dir2    dir5    
dir3    file1   
```

This listing contains a mix of files and directories - there is no way to tell which is which simply based on their names.  In order to distinguish between them, we need some metadata on each item in this listing.

---

# Navigating with *NIX
## How do I see what hidden directories and files are within the current working directory?
Hidden files and directoriess simply begin with the '.' character.  To view a listing of files and directories including them, use the `a` flag on the `ls` command.

```console
foo@bar$ ls -a
.hidden_dir1    dir1    dir4    file2
.hidden_dir2    dir2    dir5    
.hidden_file1   dir3    file1   
```

Both files and directories may be hidden by naming them prefixed with a period,`.`.

---

# Navigating with *NIX
## File listing with metadata
To view a listing of files and directories including metadata about each item, use the `l` flag on the `ls` command.

```console
foo@bar$ ls -a
drwx------+ 10 foo  bar   320 Sep  4 10:41 dir1 
drwx------+ 19 foo  bar   608 Aug 30 21:38 dir2
drwx------+  8 foo  bar   256 Nov 27  2017 dir3
drwx------+  4 foo  bar   128 Dec 31  2016 dir4
drwx------+ 19 foo  bar   611 Aug 21 21:38 dir5
-rwx------+ 10 foo  bar   320 Sep  4 10:41 file1
-rwx------+ 19 foo  bar   608 Aug 30 21:38 file2
```

To include hidden files in the listing, combine the `-l` and `-a` flags.
```console
foo@bar$ ls -la
...
```

---

# Navigating with *NIX
## What does all that metadata mean?

```console
foo@bar$ ls -a
drwx------+ 10 foo  bar   320 Sep  4 10:41 dir1 
drwx------+ 19 foo  bar   608 Aug 30 21:38 dir2
drwx------+  8 foo  bar   256 Nov 27  2017 dir3
drwx------+  4 foo  bar   128 Dec 31  2016 dir4
drwx------+ 19 foo  bar   611 Aug 21 21:38 dir5
-rwx------+ 10 foo  bar   320 Sep  4 10:41 file1
-rwx------+ 19 foo  bar   608 Aug 30 21:38 file2
```

The metadata included in a long listing of files and directories in the working directory indicates a few different things, including:
- directories are indicated by a `d` at the beginning of the line, files show `-` instead.
- the user who owns each of the items can read, write and execute each of them, indicated by the `rwx` letters in each line.  No other users can do any of these things with these items.
- the single user `foo` owns all these items
- the group of users named `bar` owns all these items

---

# Navigating with *NIX
## File permissions

```console
-rwxr-xr--+ 10 foo  bar   320 Sep  4 10:41 file1.sh
```

Given the file metadata above, we can see the following permission settings:
- the user who owns the file, named `foo` can read, write and execute the file.
- the group who owns the file, named `bar` can read and execute the file, but cannot write to it.
- everyone else can only read the file, but not write or execute it.

Revoke permissions with the `-` sign.  In this case we revoke the user `foo`'s execute permission:
```console
foo@bar$ chmod u-x file1.sh
```

Revoke permissions with the `+` sign.  In this case we grant the group `bar` write permission:
```console
foo@bar$ chmod g+w file1.sh
```

All other users besides the user and group who own the file are known as 'others' and can have permissions granted or revoked as well:
```console
foo@bar$ chmod o+wx file1.sh
```


---

# Navigating with *NIX
## How do I drill down?
To navigate to sub-directory that is within the current directory, use the `cd` command with the name of the sub-directory that is the desired destination.

```console
foo@bar$ cd bar
foo@bar$ pwd
/bar
```

Note that writing `cd /bar`, with the forward slash, would navigate to a directory named `bar` that is a sub-directory of the root directory, if any such directory exists, which is not what you wanted.

You can, of course drill down several levels of directories at once.
```console
foo@bar$ cd bar/baz/blue
foo@bar$ pwd
/bar/baz/blue
```

---

# Navigating with *NIX
## How do I jump to a directory from anywhere
If you kmow the full path of a directory to which you want to navigate, type it after the `cd` command.

```console
foo@bar$ pwd
/bar/baz/blue
foo@bar$ cd /Users/foo/Documents/my_favorite_ice_cream
foo@bar$ pwd
/Users/foo/Documents/my_favorite_ice_cream
```

---

# Navigating with *NIX
## Create a blank new file
The `touch` command is useful for creating a blank file with a given name.

```console
foo@bar$ touch environmental_cosmetology.txt
```

To open up this new file in the notorious `emacs` command-line text editor:
```console
foo@bar$ emacs environmental_cosmetology.txt
```

---

# Navigating with *NIX
## Rename or move a file
Renaming is a variety of moving, using the `mv` command to move a file from one name to another.
```console
foo@bar$ mv environmental_cosmetology.txt ecdp.txt
```

Or keep its current name, but move it to an entirely different directory:
```console
foo@bar$ mv environmental_cosmetology.txt /Users/foo/Documents/
```

Or rename it and move it to an entirely different directory up two levels and down from there into a subdirectory named `baz`:
```console
foo@bar$ mv /Users/foo/Documents/environmental_cosmetology.txt ../../baz/ecdp.txt
```

---

# Navigating with *NIX
## Delete a file
The `rm` command deletes files.

Delete a file in the current working directory:
```console
foo@bar$ rm heme_rich_foods.csv
```

Delete a file in a sub-directory of the current working directory:
```console
foo@bar$ rm meat/fillers/heme_rich_foods.csv
```

Delete a file in a subdirectory of the root directory:
```console
foo@bar$ rm /meat/fillers/heme_rich_foods.csv
```

---

# Navigating with *NIX
## Delete a directory
The `rmdir` command deletes empty directories, while the `rm` command can be used to delete non-empty directories.

Delete an empty sub-directory named `meat`:
```console
foo@bar$ rmdir meat
```

Delete a non-empty directory with the `r` and `f` flags of the `rm` command:
```console
foo@bar$ rm -rf meat
```

---

# Navigating with *NIX
## Create a directory
The `mkdir` command creates an empty directory.

Make a new sub-directory named `vegetables`:
```console
foo@bar$ mkdir vegetables
```

Make a sub-directory of the parent directory:
```console
foo@bar$ mkdir ../arugula
```

Make a new directory somewhere totally different on the hard drive:
```console
foo@bar$ mkdir /Users/foo/Photos/compromising/nudes
```

---

class: center, middle

# Starter code

---

# Starter code
## Create a file
Create a new plain text file somewhere you know you can find it later.

Make a file in a new sub-directory of your user account 'home' directory (using the `~` shortcut to navigate there):
```console
foo@bar$ cd ~
foo@bar$ mkdir first_try
foo@bar$ cd first_try
foo@bar$ touch MyFirstJavaProgram.java
```

---

# Starter code
## Add starter Java code to the file

Edit the text file you just created using a text editor of your choice.
```console
foo@bar$ emacs MyFirstJavaProgram.java
```

Add the following code:
```java
public class MyFirstJavaProgram {
	public static void main(String[] args) {
		// put the main contents of your program below here
		System.out.println("Welcome to Java from the command line!");
		// put the main contents of your program above here
	}
}
```

---

# Starter code
## Save your file

If you are using the emacs editor, press `Ctrl-x Ctrl-S` to save, then `Ctrl-x Ctrl-c` to quit.

If using any other graphical user interface editor, just save the ordinary way.

---

# Starter code
## Compile the Java source code

Java code must be compiled to byte code before it can be run.  Use the `javac` command to do this.
```console
foo@bar$ javac MyFirstJavaProgram.java
```

Note the full name of the .java file to compile.

The compiler will now have automatically created a file named MyFirstJavaProgram.class in the same directory.

---

# Starter code
## Execute the Java byte code

The Java byte code can now be executed by the JVM, Java's interpreter, using the `java` command.
```console
foo@bar$ java MyFirstJavaProgram
Welcome to Java from the command line!
```

Note the command does not require the .java or .class file extension.

---

class: center, middle

# Better starter code

---

# Better starter code
## Add a package
Java code can be organized into "packages" of related files.  

Add a similar package declaration to your source code file in an editor of your choice, but replace `fb1258` with your own NYU Net ID.
```java
package edu.nyu.cs.fb1258;

public class MyFirstJavaProgram {
	public static void main(String[] args) {
		// put the main contents of your program below here
		System.out.println("Welcome to Java from the command line!");
		// put the main contents of your program above here
	}
}
```

---

# Better starter code
## Move the file to the proper location
Sadly, with a package identifier, the .java and .class files must now be located in a directory that matches the package or the JVM will not execute them.

Create an appropriate set of sub-directories, and move both files at once (replace `fb1258` with yoru own NYU Net ID):
```console
foo@bar$ mkdir edu
foo@bar$ mkdir edu/nyu
foo@bar$ mkdir edu/nyu/cs
foo@bar$ mkdir edu/nyu/cs/fb1258
foo@bar$ mv MyFirstJavaProgram.* edu/nyu/cs/fb1258
```

Of course there is a way to create all these sub-directories at once using the `p` flag to the `mkdir` command:
```console
foo@bar$ mkdir -p edu/nyu/cs/fb1258
foo@bar$ mv MyFirstJavaProgram.* edu/nyu/cs/fb1258
```


---

# Better starter code
## Recompile the Java source code.
Sadder still, the Java source code must now be re-compiled, since the byte code is no longer up to date.

```console
foo@bar$ javac edu/nyu/cs/fb1258/MyFirstJavaProgram.java
```

This will overwrite the file named `MyFirstJavaProgram.class` in the appropriate directory.

---

# Better starter code
## Re-execute the Java byte code
At this point, you have two files named `MyFirstJavaProgram.java` (source code) and `MyFirstJavaProgram.class` (byte code) in the directory `edu/nyu/cs/fb1258`, where `fb1258` is replaced with your own NYU Net ID.

Now try running it.  Here we will tell the JVM that it should look in the current working directory (nicknamed `.`) and any sub-directories for the appropriate .class files within the indicated package.

```console
foo@bar$ javac -classpath . edu.nyu.cs.fb1258.MyFirstJavaProgram
Better welcome to Java from the command line!
```

Use package identifiers from now on in all work.

---

class: center, middle

# Conclusions

---

# Conclusions
## We can now use the command line to write and run Java programs
In addition to learning a bit about the *NIX command line, you are now able to compile Java source code into Java byte code and execute the byte code using the JVM interpreter.

Bye.
