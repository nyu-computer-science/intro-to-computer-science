---
layout: presentation
title: Course overview
permalink: /starter_kit/
---

class: center, middle

# Starter kit
Welcome

---

# Agenda

1. Assumptions
2. Navigating with *NIX
3. Starter code
4. Better starter code
5. Conclusions

---

class: center, middle

# Assumptions

---

# Assumptions
## Ability to run *NIX commands
In order to run Unix or Linux commands, you will need a terminal emulator:
- OS X users already have the Terminal app we will use for this purpose.
- Windows users must have [Git for Windows](https://gitforwindows.org/) installed.

---

# Assumptions
## Ability to execute Java programs
You will need to have the [Java Development Kit](https://www.oracle.com/technetwork/java/javase/downloads/) installed.

If you have any terminal emulators open (such as Terminal or Git Bash), close them and reopen them.

---

# Assumptions
## Understanding of plain text
Plain text is a term frequently used to mean one data on a computer that is represented as codes in the ASCII encoding system or the Unicode encoding system, a successor to ASCII.

These coding systems map specific numeric codes to every text character.  For example, the letter `C` might be 42 and `D` might be 43.  When you as a human see plain text on your screen or type text characters on your keyboard, chances are the computer behind the scenes willl store that text's numeric codes (in binary) according to one of these two encoding systems.  

A plain text file is a file that has nothing but numeric codes that map out to characters in one of these systems.  Unicode is today's standard and includes everything ASCII did, plus more.

---

# Assumptions
## Ability to edit text
Computer programming code is plain text.  In order to edit code, you will need a decent plain text editor program.
- Install [Sublime Text](https://www.sublimetext.com/), a freee good quality plain text editor.
- Sublime Text is freeware, but periodically will ask for donations. You are not required to donate.

Warnings:
- Never use TextEdit on OS X to edit code.
- Never use Notepad on Windows to edit code.
- Do not use Microsoft Word or Google Docs to edit code
- Beware of emacs, lest you find yourself forever dreaming of keyboard shortcuts.

---

# Assumptions
## Ability to edit text
Emacs is a plain text editor that can be run from the command line.

If you want to have the most fun with the *NIX command line, use Emacs instead of Sublime Text.

Emacs functionality depends upon a lot of keyboard shortcut combinations.  The following will get you started:
- `Ctrl-x Ctrl-s` to save a file
- `Ctrl-x Ctrl-c` to quit emacs

Learn moree shortcuts with an [emacs cheat sheet](https://duckduckgo.com/?q=emacs+cheat+sheet&t=brave&ia=cheatsheet&iax=1).

---

class: center, middle

# Navigating with *NIX

---

# Navigating with *NIX
## Overview
Unix commands are necessary in order to be able to navigate directories/folders in a UNIX-like system.
- all Unix commands are run in the command-line interface, such as that offered by Terminal on OS X or Git Bash on Windows.

Review [basic Unix commands](https://knowledge.kitchen/Basic_UNIX/Linux_file_management).

---

# Navigating with *NIX
## Where am I?
At any point in time, you are actively within one specific directory, known as the current working directory.  To determine which directory that is at any point, run the `pwd` command:

```bash
foo@bar$ pwd
/Users/foo
```

Read more about the [current working directory](https://knowledge.kitchen/Basic_computer_concepts#The_working_directory).

---

# Navigating with *NIX
## How do I go up one level
To navigate up one level in the directory structure of your hard drive, use the `..` shortcut no matter where you currently are.

```bash
foo@bar$ pwd
/Users/foo
foo@bar$ cd ..
foo@bar$ pwd
/Users
foo@bar$ cd ..
foo@bar$ pwd
/
```

---

# Navigating with *NIX
## How do I get to the top?
To navigate to the top-most directory of your hard drive, known as the "root directory", use the `cd` command with the `/` symbol indicating root directory as the desired destination.

```bash
foo@bar$ cd /
foo@bar$ pwd
/
```

The current working directory is now the root directory.

---

# Navigating with *NIX
## How do I see what directories and files are within the current working directory?
Use the `ls` command to show non-hidden files and directories that are within the current working directory.

```bash
foo@bar$ ls
dir1    dir4    file2
dir2    dir5    file3
dir3    file1   file4
```

---

# Navigating with *NIX
## How do I see what hidden directories and files are within the current working directory?
Hidden files and directoriess simply begin with the '.' character.  To view a listing of files and directories including them, use the `a` flag on the `ls` command.

```bash
foo@bar$ ls -a
.hidden_dir1    dir1    dir4    file2
.hidden_dir2    dir2    dir5    file3
.hidden_file1   dir3    file1   file4
```

---

# Navigating with *NIX
## How do I see more information about each of the files and directories in the listing?
To view a listing of files and directories including metadata about each item, use the `l` flag on the `ls` command.

```bash
foo@bar$ ls -a
drwx------+ 10 foo  bar   320 Sep  4 10:41 dir1 
drwx------+ 19 foo  bar   608 Aug 30 21:38 dir2
drwx------+  8 foo  bar   256 Nov 27  2017 dir3
drwx------+  4 foo  bar   128 Dec 31  2016 dir4
drwx------+ 19 foo  bar   611 Aug 21 21:38 dir5
-rwx------+ 10 foo  bar   320 Sep  4 10:41 file1
-rwx------+ 19 foo  bar   608 Aug 30 21:38 file2
-rwx------+  8 foo  bar   256 Nov 27  2017 file3
-rwx------+  4 foo  bar   128 Dec 31  2016 file4
```

To include hidden files in the listing, combine the `-l` and `-a` flags.
```console
foo@bar$ ls -la
...
```

---

# Navigating with *NIX
## How do I drill down?
To navigate to sub-directory that is within the current directory, use the `cd` command with the name of the sub-directory that is the desired destination.

```bash
foo@bar$ cd bar
foo@bar$ pwd
/bar
```

Note that writing `cd /bar`, with the forward slash, would navigate to a directory named `bar` that is a sub-directory of the root directory, if any such directory exists, which is not what you wanted.

---

# Navigating with *NIX
## How do I jump to a directory from anywhere
If you kmow the full path of a directory you want to navigate to, type it after the `cd` command.

```bash
foo@bar$ pwd
/bar/baz
foo@bar$ cd /Users/foo/Documents/my_favorite_ice_cream
foo@bar$ pwd
/Users/foo/Documents/my_favorite_ice_cream
```

---

# Navigating with *NIX
## Create a blank new file
The `touch` command is useful for creating a blank file with a given name.

```bash
foo@bar$ touch environmental_cosmetology_degree_programs.txt
```

To open up this new file in the command-line text editor:
```bash
foo@bar$ emacs environmental_cosmetology_degree_programs.txt
```

---

# Navigating with *NIX
## Create a blank new file
The `touch` command is useful for creating a blank file with a given name.

```bash
foo@bar$ touch environmental_cosmetology_degree_programs.txt
```

To open up this new file in the command-line text editor:
```bash
foo@bar$ emacs environmental_cosmetology_degree_programs.txt
```

---

# Navigating with *NIX
## Rename or move a file
Renaming is a variety of moving, using the `mv` command to move a file from one name to another.
```bash
foo@bar$ mv environmental_cosmetology_degree_programs.txt ecdp.txt
```

Or keep its current name, but move it to an entirely different directory:
```bash
foo@bar$ mv environmental_cosmetology_degree_programs.txt /Users/foo/Documents/
```

Or rename it and move it to an entirely different directory:
```bash
foo@bar$ mv /Users/foo/Documents/environmental_cosmetology_degree_programs.txt /Users/foo/Documents/ecdp.txt
```

---

# Navigating with *NIX
## Delete a file
The `rm` command deletes files.

Delete a file in the current working directory:
```bash
foo@bar$ rm heme_rich_foods.csv
```

Delete a file in a sub-directory of the current working directory:
```bash
foo@bar$ rm meat/fillers/heme_rich_foods.csv
```

Delete a file in a subdirectory of the root directory:
```bash
foo@bar$ rm /meat/fillers/heme_rich_foods.csv
```

---

# Navigating with *NIX
## Delete a directory
The `rmdir` command deletes empty directories, while the `rm` command can be used to delete non-empty directories.

Delete an empty sub-directory named `meat`:
```bash
foo@bar$ rmdir meat
```

Delete a non-empty directory with the `r` and `f` flags of the `rm` command:
```bash
foo@bar$ rm -rf meat
```

---

# Navigating with *NIX
## Create a directory
The `mkdir` command creates an empty directory.

Make a new sub-directory named `vegetables`:
```bash
foo@bar$ mkdir vegetables
```

Make a sub-directory of the parent directory:
```bash
foo@bar$ mkdir ../arugula
```

Make a new directory somewhere totally different on the hard drive:
```bash
foo@bar$ mkdir /Users/foo/Photos/compromising/nudes
```

---

class: center, middle

# Starter code

---

# Starter code
## Create a file
Create a new plain text file somewhere you know you can find it later.

Make a file in a new sub-directory of your user account 'home' directory (using the `~` shortcut to navigate there):
```bash
foo@bar$ cd ~
foo@bar$ mkdir first_try
foo@bar$ cd first_try
foo@bar$ touch MyFirstJavaProgram.java
```

---

# Starter code
## Add starter Java code to the file

Edit the text file you just created using a text editor of your choice.
```bash
foo@bar$ emacs MyFirstJavaProgram.java
```

Add the following code:
```java
public class MyFirstJavaProgram {
	public static void main(String[] args) {

		System.out.println("Welcome to Java from the command line!");

	}
}
```

---

# Starter code
## Save your file

If you are using the emacs editor, press `Ctrl-x Ctrl-S` to save, then `Ctrl-x Ctrl-c` to quit.

If using any other graphical user interface editor, just save the ordinary way.

---

# Starter code
## Compile the Java source code

Java code must be compiled to byte code before it can be run.  Use the `javac` command to do this.
```bash
foo@bar$ javac MyFirstJavaProgram.java
```

Note the full name of the .java file to compile.

The compiler will now have automatically created a file named MyFirstJavaProgram.class in the same directory.

---

# Starter code
## Execute the Java byte code

The Java byte code can now be executed by the JVM, Java's interpreter, using the `java` command.
```bash
foo@bar$ java MyFirstJavaProgram
Welcome to Java from the command line!
```

Note the command does not require the .java or .class file extension.

---

class: center, middle

# Better starter code

---

# Better starter code
## Add a package
Java code can be organized into "packages" of related files.  

Add a similar package declaration to your source code file in an editor of your choice, but replace `fb1258` with your own NYU Net ID.
```java
package edu.nyu.cs.fb1258;

public class MyFirstJavaProgram {
	public static void main(String[] args) {

		System.out.println("Better welcome to Java from the command line!");

	}
}
```

---

# Better starter code
## Move the file to the proper location
Sadly, with a package identifier, the .java and .class files must now be located in a directory that matches the package or the JVM will not execute them.

Create an appropriate set of sub-directories, and move both files at once:
```bash
foo@bar$ mkdir edu
foo@bar$ mkdir edu/nyu
foo@bar$ mkdir edu/nyu/cs
foo@bar$ mkdir edu/nyu/cs/fb1258
foo@bar$ mv MyFirstJavaProgram.* edu/nyu/cs/fb1258
```

---

# Better starter code
## Recompile the Java source code.
Sadder still, the Java source code must now be re-compiled, since the byte code is no longer up to date.

```bash
foo@bar$ javac edu/nyu/cs/fb1258/MyFirstJavaProgram.java
```

This will overwrite the file named `MyFirstJavaProgram.class` in the appropriate directory.

---

# Better starter code
## Re-execute the Java byte code
Now try running it.  Here we will tell the JVM that it should look in the current working directory (nicknamed `.`) and any sub-directories for the appropriate code with the indicated package.

```bash
foo@bar$ javac classpath . edu.nyu.cs.fb1258.MyFirstJavaProgram
Better welcome to Java from the command line!
```

Use package identifiers from now on.

---

class: center, middle

# Conclusions

---

# Conclusions
## We can now write and run Java programs
In addition to learning a bit about the *NIX command line, you are now able to compile Java source code into Java byte code and execute the byte code using the JVM interpreter.

Bye.
